import crypto from 'node:crypto'
import { timingSafeEqualStr } from './crypto'
import { getDB, saveDB } from './db'

const COOKIE_NAME = 'admin_session'

function getSecret() {
  return process.env.AUTH_SECRET ?? 'dev-secret-change-me'
}

function sign(payload: string) {
  const h = crypto.createHmac('sha256', getSecret())
  h.update(payload)
  return h.digest('base64url')
}

export function makeSessionToken(username: string) {
  const payload = JSON.stringify({ u: username, ts: Date.now() })
  const b64 = Buffer.from(payload, 'utf8').toString('base64url')
  const sig = sign(b64)
  return `${b64}.${sig}`
}

export function verifySessionToken(token: string | undefined | null) {
  if (!token) return null
  const [b64, sig] = token.split('.')
  if (!b64 || !sig) return null
  const expected = sign(b64)
  if (!timingSafeEqualStr(sig, expected)) return null
  try {
    const json = Buffer.from(b64, 'base64url').toString('utf8')
    const obj = JSON.parse(json) as { u: string; ts: number }
    if (!obj?.u) return null
    // 7 days
    if (Date.now() - obj.ts > 7 * 24 * 60 * 60 * 1000) return null
    return obj
  } catch {
    return null
  }
}

export function getCookieName() {
  return COOKIE_NAME
}

export async function verifyAdminCredentials(username: string, password: string) {
  const db = await getDB()
  if (db.admin.username !== username) return false
  const cryptoMod = await import('./crypto')
  const { hash } = cryptoMod.hashPassword(password, db.admin.passwordSalt)
  return timingSafeEqualStr(hash, db.admin.passwordHash)
}

export async function changeAdminPassword(curr: string, next: string) {
  const db = await getDB()
  const cryptoMod = await import('./crypto')
  const currHash = cryptoMod.hashPassword(curr, db.admin.passwordSalt).hash
  if (!timingSafeEqualStr(currHash, db.admin.passwordHash)) {
    return { ok: false as const, reason: 'invalid_current' as const }
  }
  const { salt, hash } = cryptoMod.hashPassword(next)
  db.admin.passwordSalt = salt
  db.admin.passwordHash = hash
  await saveDB(db)
  return { ok: true as const }
}

import crypto from "node:crypto";

const __COOKIE_NAME = process.env.ADMIN_SESSION_COOKIE ?? "seatba_admin_session";
const __SECRET =
  process.env.ADMIN_SESSION_SECRET ??
  process.env.NEXTAUTH_SECRET ??
  "dev-secret-change-me";

export function createSessionToken(payload: any = { sub: "admin" }) {
  const body = Buffer.from(
    JSON.stringify({ ...payload, iat: Date.now() })
  ).toString("base64url");

  const sig = crypto.createHmac("sha256", __SECRET).update(body).digest("base64url");
  return `${body}.${sig}`;
}

function __verifySessionToken(token: string) {
  const [body, sig] = (token || "").split(".");
  if (!body || !sig) return false;
  const expected = crypto.createHmac("sha256", __SECRET).update(body).digest("base64url");
  try {
    const a = Buffer.from(sig);
    const b = Buffer.from(expected);
    if (a.length !== b.length) return false;
    return crypto.timingSafeEqual(a, b);
  } catch {
    return false;
  }
}

export function setSessionCookie(res: any, token: string) {
  // For NextResponse (Route Handlers): res.cookies.set(...)
  res?.cookies?.set?.(__COOKIE_NAME, token, {
    httpOnly: true,
    sameSite: "lax",
    secure: process.env.NODE_ENV === "production",
    path: "/",
  });
}

export function clearSessionCookie(res: any) {
  res?.cookies?.set?.(__COOKIE_NAME, "", {
    httpOnly: true,
    expires: new Date(0),
    path: "/",
  });
}

export async function requireAdminApi(req: any) {
  const token =
    req?.cookies?.get?.(__COOKIE_NAME)?.value ??
    req?.cookies?.[__COOKIE_NAME] ??
    "";

  if (!token || !__verifySessionToken(token)) {
    const err: any = new Error("UNAUTHORIZED");
    err.status = 401;
    throw err;
  }
  return { ok: true, role: "admin" };
}

// Placeholder to satisfy imports (implement persistence if needed)
export async function rotateAdminPassword(_newPassword: string) {
  return { ok: true };
}
